<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>RatesMate technical overview - Benjamin Henshall</title>
	<link rel="stylesheet" href="../stylesheets/screen.css">
	<link rel="icon" href="../images/computer.png">
	<link href='http://fonts.googleapis.com/css?family=Lato:100,300,400' rel='stylesheet' type='text/css'>

	<!--Google analytics-->
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-83011840-1', 'auto');
	  ga('send', 'pageview');

	</script>

</head>
<body>

	<header class="primary-header container group">
		<h1 class="logo">
			<a href="../index.html">Benjamin Henshall</a>
		</h1>
		<h3 class="tagline">
			<a target="_blank" href="https://github.com/Ben-Henshall">
				<img class="iconimg" src="../images/GitHub icon.png"></img>&nbsp;&nbsp;&nbsp;
			</a>
			<a target="_blank" href="https://www.linkedin.com/in/benjamin-henshall">
				<img class="iconimg" src="../images/LinkedIn icon.png"></img>
			</a>
		</br>
	</br>
	iOS Developer</h3>
	<nav class="nav primary-nav">
		<ul>
			<li><a href="../index.html">Home</a></li><!--
	--><li><a href="../about.html">About Me</a></li><!--
	--><li><a href="../portfolio.html">Portfolio</a></li><!--
	--><li><a href="../cv.html">CV</a></li><!--
	--><li class="selected-page"><a href="../blog.html">Blog</a></li><!--
	--><li><a href="../contact.html">Contact</a></li>
</ul>
</nav>

</header>

<section class="row-alt">
	<div class="lead container">

		<h1 text-align="center">Blog // TODO: Spell check whole site</h1>

	</div>
</section>

<section class="row">
	<div class="container blog-entry">
		<a target="_blank" href="https://www.appstore.com/RatesMateCurrencyConverter">
			<img class="appicon-center" src="../images/RatesMateAppIcon.png" alt="RatesMate app icon" width="200">
		</a>
		<h1>RatesMate - A technical overview // TODO, add links to frameworks</h1>

	<ol>
		<a href="#section1"><li>What is RatesMate, and why does it exist?</li></a>
		<a href="#section2"><li>Technologies</li></a>
		<a href="#section3"><li>Architecture & Design Patterns</li></a>
		<a href="#section4"><li>Issues Faced</li></a>
		<a href="#section5"><li>Future Improvements</li></a>
		<a href="#section6"><li>Misc</li></a>
		<a href="#section7"><li>Special Thanks</li></a>
	</ol>
	</br>
	<h2><a name="section1">What is RatesMate, and why does it exist?</a></h2>
	<div class="grid">
		<div class="col-1-3">
			<figure>
				<img src="../images/RatesMateScreenshot.png" width=100%></img>
				<figcaption><h5>RatesMate Currency Converter</h5></figcaption>
			</figure>
		</div>
		<div class="col-2-3">
			<p>RatesMate is a simple yet powerful currency conversion app. RatesMate includes currency rates for over 150 currencies and includes tipping customs for 65 countries.</p>
			<p>RatesMate was designed and built as a portfolio app. An app which further me as an iOS developer and allow me to see the full design, implementation and release stages of an iOS project. More specifically, I could use it as an opportunity to try using RxSwift in a full app implementation.</p>
			<p>The reason I decided to create a currency conversion app boils down to a few things:</p>
			<ul>
				<li><p>The app would make use <b>free</b> REST APIs. I wanted the only financial investment to be the Apple developer account fee.</p></li>
				<li><p>Updating information asynchronously over the networking, then propagating the received data throughout the app is a perfect use case for the Rx paradigm.</p></li>
				<li><p>The tipping unique selling point of the app isn't implemented in too many conversion apps that I have seen.</p></li>
				<li><p>It would be an app I would make use of whenever I go abroad.</p></li>
			</ul>
		</div>
	</div>
	<p>I aimed to keep the UX design simple and focus heavily on good code practices, architecture and design patterns. A summary of these implementation details will be discussed in the following sections.</p>
	</br>

	<h2><a name="section2">Technologies</a></h2>
	<p>As mentioned in the previous chapter, one of the main driving forces behind RatesMate was the desire to use RxSwift in a full app environment. The entirety of the app makes use of the reactive programming paradigm - networking, data flow and even the chaining of animations.</p>
	<p>Paired with RxSwift, I made use of RxCocoa. RxCocoa contains a bunch of useful Cocoa extensions to provide rx-y functionality - such as being able to use the response from a URLSession through an observable, or publishing text property updates to UILabels through bindings.</p>
	<p>Both RxTest and RxBlocking are included in the same repo as RxSwift and RxCocoa. These are used extensively in my unit tests, to efficiently and correctly ensure that my code is working, allowing me to confidently refactor in the future.</p>
	<p>Other Rx related libraries used were:</p>
	<ul>
		<li><b>RxAnimated:</b> Allows animated sinks to be added to data bindings - rather than normally binding a subject to say, a UILabels text bindable, you can specify an animation type and duration, so that when the subject emits an event the UILabel updates the text property with the given animation.</li>
		<li><b>Action:</b> Used to execute work by subscribing to an observable when the action receives an input. Allows the button state to be disabled while the observable is being subscribed to, preventing multiple executions</li>
		<li><b>RxDataSources:</b> RxCocoa offers some extensions for powering UITableView, but they're not quite as powerful as using RxDataSources. RxDataSources has an highly optimised diff algorithm for inserting, deleting and updating cell content within a UITableView.</li>
		<li><b>RxGesture:</b> Converts gesture events into an observable stream. I only really use this in the continent selection screen, but wanted to try out the library so added it as a dependency anyway.</li>
		<li><b>RxStoreKit:</b> Allows access to the StoreKit API in a functional, reactive manner.</li>
	</ul>
	<p>To help with debugging in both the development stage and in production, I used the CocoaLumberjack logging framework as I am familiar with it.</p>
	<p>Evaluating calculations that the user has entered required two dependencies. The calculator had to be able to evaluate a string of operations (e.g. "1 + 2 / 3") and be able to deal with very large denominations of currency, since some conversions would be in large amounts (An example being converting Euros to Vietnamese Dong).
		For the first requirement, I used "Expression", an iOS library that can evaluate a string and output a double value. For the second requirement, I used Swift-Big-Number.</p>
	<p>However, due to Expression outputting the value as a double as the largest datatype, I had to use a modified version of Expression that included the BigNumber library, which could then evaluate an expression and return a BigNumber datatype instead.
		The BigNumber library also required some modification to fix some accuracy issues, so I forked both of these repos and stored them on my own GitHub. I updated the podspecs and created my own private podspecs repo, so that I could use CocoaPods to load private repos.</p>

	<p>I opted for Firebase as my backend technology, using a combination of both the database and cloud functions. I load from 2 APIs, one for country info and one for currency exchange rates. These are loaded into the database by two cloud functions (Cloud functions are JS code executed upon a GET request to an address), which is then pulled down to the app. These functions are executed by Cron jobs hosted by another free service.</p>
	<p>Using Firebase in this approach may have been overkill, since I'm not making use of many of the features Firebase has to offers, but I struggled to find a free cloud computing service that would let me host my own endpoint, without having to run my own server. I suppose I now get Firebase analytics without any extra hassle.</p>
	<p>The APIs used were RESTCountries and CurrencyLayer.</p>
	<p>In terms of iOS SDK APIs, I made use of both UIKit (Pretty much guaranteed in any iOS project) and StoreKit.</p>
	<p>All of the above dependencies were integrated using CocoaPods (some through a private podspec as mentioned above), as Firebase requires installation using CocoaPods (due to statically linked libraries). I began the project using Carthage, which is my preference. I usually setup Carthage to not build the checkouts and to instead incorporate the checkouts into a single workspace, allowing me to control what is built for each target.</p>
	<p>During the design phase, I designed wireframes in Sketch to get an idea of what I wanted the app to look like. I also designed the app logo in Sketch.</p>
	<p>To maintain a consistent code style, I added Swiftlint as a run script phase.</p>
	<p>I managed the app store metadata and released builds to TestFlight using fastlane. This dramatically sped up the process of releasing a beta/release build, as well as allowed me to clearly store the app store metadata under version control. The app store screenshots were produced using fastlanes snapshot & frameit.</p>
	<p>The project was maintained in source control with Git on the GitLab service.</p>
	<center>
		<figure>
			<img src="../images/GitHistoryScreenshot.png" alt="Git commit frequency graph" width=50%>
			<figcaption><h5>Commit history of the RatesMate project</h5></figcaption>
		</figure>
	</center>
	</br>

	<h2><a name="section3">Architecture & Design Patterns</a></h2>
	<h4>Architecture</h4>
	<p>When it came to deciding on an architecture, I narrowed down to two choices: the traditional <b>M</b>odel-<b>V</b>iew-<b>C</b>ontroller pattern or <b>M</b>odel-<b>V</b>iew-<b>V</b>iew<b>M</b>odel.</p>
	<p>I had used both architectures in projects previously, MVC in smaller personal projects and MVVM at my previous workplace. The argument for each was fairly even.</p>
	<p>One of the most popular reasons to avoid MVC to avoiding is ViewController bloat, but this only really becomes an issue if MVC is implemented badly. Functionality should still be separated from view controllers into separate units (Handlers, service classes, extensions etc). MVC starts to go awry when the requirements for functionality to be separated into new units is not clearly defined - this can have disastrous consequences on large code bases, causing tight coupling between view logic and business logic. This issue is much easier to minimise in a single-developer project as the decisions of separation are more consistent, provided the developer is disciplined in following a decoupled structure.</p>
	<p>MVVM helps with this separation by completely separating the view logic and the business logic. The View module of MVVM (Which includes the ViewController) simply displays data from the ViewModel. An excellent rule I use when developing in an MVVM architecture is to always design the ViewModel as if I was going to build a MacOS app, identical to the iOS app, and use the ViewModel to power the AppKit based ViewController.</p>
	<p>Since MVVM is popular in apps that use RxSwift (partly due to the data flow from the ViewModel to it's owner ViewController being trivialised), I decided to opt for MVVM as any company I make work for in the future would likely use RxSwift and therefore likely use the MVVM architecture.</p>
	<p>To exemplify how the ViewModel and ViewController exchange data, I have created two code snippets of a simple ViewModel/ViewController pairing from my app. The UI elements have been removed from these classes since that is not the focus of the snippet. I've also updated it to use UILabels/UIButtons rather than a using a UITableView to reduce complexity.</p>
	<script src="https://gist.github.com/Ben-Henshall/c21df26dfd4c492a520360b2a18541b0.js"></script>
	<p>A couple of things to point out:</p>
	<ul>
		<li>The business logic of what information to display, how it should be formatted and how to update the state is exclusively contained within the ViewModel. This means that testing this logic is faster (i don't have to load any UI elements/storyboards to test the logic) and the testing can also be separated into a framework, which could then be shared across multiple targets (a MacOS app, for example).</li>
		<li>State updates in the ViewModel are automatically detected and updated in the ViewController - this is the binding aspect of the data flow from the ViewModel to the ViewController.</li>
		<li>Transitions between ViewControllers is handled entirely within the ViewModel by use of the SceneCoordinator. This makes testing VC transitions and verifying the resulting ViewModel much easier. The SceneCoordinator is covered in more detail in the <a href="#design-patterns">design patterns</a> section.</li>
		<li><code>closeAction</code> is an example of the Action library. Once the <code>closeButton</code> has been tapped, the <code>closeButton</code> won't be usable until <code>sceneCoordinator.pop().asObservable().map { _ in }</code> emits an event.</li>
	</ul>

	<h4><a name="design-patterns">Design Patterns</a></h4>
	<h5>Scene Coordinator</h5>
	<p>One of my favourite aspects of the app (in terms of programming) is the SceneCoordinator service class. While not the same as the traditional coordinator pattern found in iOS (where there are child coordinators, one for each navigational flow), the SceneCoordinator still maintains the separation of navigation logic to display logic and couples closely with business logic - meaning you can write better & faster unit tests.</p>
	<p>The coordinator is used to transition between scenes (ViewControllers) using whichever transition type specified (Root, Push, Modal, pop) by holding a reference to the current navigation controller and manipulating it whenever the scene needs to change.</p>
	<p>This modified design pattern was first presented to me in the RayWenderlich RxSwift book.</p>

	<h5>Dependency Injection</h5>
	<p>The second major design pattern implemented in the RatesMate app was favouring dependency injection over my previous experience of singletons.</p>
	<p>In total, there were three dependencies that were passed throughout the app:</p>
	<ul>
		<li><b>SceneCoordinator</b>: controls transitions between scenes - mentioned in the section above.</li>
		<li><b>DatabaseHandler</b>: allows access to data pulled from the database source. This is the country information and currency exchange rates. Data pulled here is cached in the documents directory (file sharing is disabled so the user can't see these) when pulled and periodically pulls new exchange rates every 12 hours and new country information every 7 days.</li>
		<li><b>IAPHandler</b>: encapsulates relevant StoreKit functionality, including unlocking the additional currencies, restoring previous purchases, the price of the additional unlock as well as requesting an app store review.</li>
	</ul>
	<p>Each of these dependencies is simply a protocol, with concrete implementations being passed between the classes. This means that if I were to switch database services, I would only need to update where the instance is first created and passed - rather than (if it was a singleton) changing many references to the singleton instance throughout the app.</p>
	<p>It also makes the app much cleaner to test. If I was using singletons, I would need to update the shared instance to return a mock class when executed within an XCTest case. Not only does this mean you're affecting production code, but it also means that you need to make the state of the mock class multiple in order to update what the mock behaviour should be.</p>
	<p>With dependency injection, I can keep the mock dependency class within the test bundle (nowhere near production code!) and pass that into the ViewModel initialiser when creating the ViewModel in unit tests - which also allows me full access to the mutable mock dependency class. Excellent!</p>

	<h5>Programatic Constraints</h5>
	<p>Having only previously used Autolayout and "UI building" in storyboards/xibs, switching to using programatic constraints was a daunting prospect. For the first few screens of the app I carried on with the familiarity and used storyboards, but soon realised that there are a large amount of companies that do their constraints completely programatically and without a storyboard due to the issues surrounding them (Source control diffs, magic strings for segues etc). Once I had realised that this was the case, I decided to switch to building the rest of my app using programatic constraints.</p>
	<p>This task was nowhere near as daunting as I originally thought! Building the constraints can become verbose pretty quickly, but I believe people have already fixed this kind of issue in some frameworks - I'll likely take a look at those for my next project.</p>
	<p>One thing did annoy me when I first started programatic constraints though: <code>translatesAutoresizingMaskIntoConstraints</code> is so easy to miss!</p>
	</br>

	<h2><a name="section4">Issues Faced</a></h2>
	<p>The biggest issue, by far, was going into this project without a good knowledge of RxSwift - how it works, how to structure the app, what the operators do or even the errors that are common and how to fix them.</p>
	<p>After struggling with Rx for the first screen, I decided that trying to progress further without having a good base knowledge of both the Reactive paradigm and the actual framework itself would be counterproductive and would compound bad habits into my coding. I took a step back and picked up the <a target="_blank" href="https://store.raywenderlich.com/products/rxswift">RxSwift book by RayWenderlich.</a> I spent a week working my way through the material, performing the exercises and reading other materials around it. After that week, I moved back to the app and began work again.</p>
	<p>The book helped <b>immensely</b> with understanding how I should structure my app. I learnt all the major operators and how to apply them, which traits and where to use them, and more. The only thing that it didn't really help me with was the plethora of uninformative RxSwift specific errors that occur when writing code. Those were a matter of just writing enough RxSwift related code to figure out. An example of these errors is "Statement is ambigious", which seems to usually be fixed by defining what type the parameters are and what type is returned by the closure.</p>
	<p>Explain how the calculators work with expressions, explain changes required to get a large expression correct - including podspecs repo</p>
	<p>I briefly mentioned the issue of math-related dependencies required in the <a href="#section2">technologies section.</a> I required two dependencies - one for big number datatypes in Swift and one to execute math expressions. Since both of these dependencies operate as separate entities, I required a merging of the two. Doing so required learning about how to use Cocoapods with private repositories - I forked both of the repos (i had to have a private repo of Big-Number due to some precision issues), updated the dependency to add the returning of big numbers from the expression library (and fixed the precision issues in Big-Number) and updated the podspec file in each of those repos to a private name. I then created a private podspec repo containing these podspecs, which are then included in the list of pods when using Cocoapods.</p>
	<p>The solution, in terms of implementation, was pretty simple and didn't require a large amount of work. I was, however, surprised by the lack of information on how to do this - I thought that using private pods would be a common use case in the industry.</p>
	<p>GDPR compliance</p>
	<p>My app was close to ready to launch on the week of May 25th. The week that GDPR came into action, if you don't remember. I spent a large amount of time reading over the legislation and what it meant for my app. Although I wasn't specifically gathering user information or using personal details, I do use pseudonymous analytic information/crashlytics in my app to track time spent on the app and improve the app. Under GDPR, this requires the users consent.</p>
	<p>The solution I implemented for this issue was to show the user an alert dialog upon launch and ask for consent for analytics & crashlytics. While this isn't the best user experience, it does ensure that my analytics/crashlytics is enabled straight away in the app and allows users to immediately opt out.</p>
	<p>Minor issue, explain use of border animations for currencies when launching app</p>
	<p>A large amount of time was spent making small UX changes to accommodate for "less computer inclined" users. Ensuring the app is usable and intuitive for all users was very important to me.</p>
	<p>An example of one of these changes is the border animation around the country flags on the calculator screen. After giving the app to a few non-tech oriented users, I noticed that they were struggle to understand how to change between currencies (by clicking on the country/currency flag), despite the younger audiences instantly understanding that clicking the flags would allow them to switch between currencies.</p>
	<p>I had two options:</p>
	<ul>
		<li>Make a user/help guide. I didn't like this option, as the app should be simple and intuitive enough to not require a step-by-step. Maybe if more complexity was added to the app, then this would be acceptable, but in it's current state it should be easy enough to use that anyone can pick it up and figure it out without too much issue. A section in the out-of-box/onboarding flow would have sufficed as a help guide.</li>
		<li>Add some kind of indication that the flag is interactive. Once the user has selected it even once, then that should be enough for them to remember the next time. Either a full flag animation (fading in/out or changing alpha over a grey background) or adding a border animation. I figured the full flag animation may be a bit disruptive to the users that already know how to switch currencies, so instead opted for the border animation. The implementation for this was trivial.</li>
	</ul>
	<center>
		<figure>
			<img src="../images/RatesMateBorderAnimation.gif" alt="Example of border animation" height=500>
			<figcaption><h5>RatesMate Border Animation</h5></figcaption>
		</figure>
	</center>
	</br>

	<h2><a name="section5">Future Improvements</a></h2>
	<p>Want to add a history graph for currencies, but would have to pay for an extra API Service</p>
	<p>Want to integrate cryptocurrencies</p>
	<p>Want to add today extension - a small calculator that only includes numbers, clear and erase</p>
	<p>Refactor Calculator view model, as it is currently quite large and should be split into other services/classes</p>
	<p>Refactor UserDefaults to be encapsulated within handler class, which is passed around through DI.
	Currently implemented as UserDefaults extension, but this prevents stored properties meaning I can't use UserDefaults
	properties as observables.</p>
	<p>Notifications for when Rates drop below a certain amount</p>
	<p>Make accessible (VoiceOver, larger text fonts)</p>
	<p>Add force touch to change currencies</p>
	</br>

	<h2><a name="section6">Misc</a></h2>
	<p>Praise Codable</p>
	<p>Praise multi line editing</p>
	<p>Post gist of Rx Action areNoActionsExecuting and give explanation</p>
	<p>StoreKit sucks for developers</p>
	</br>

	<h2><a name="section7">Special Thanks</a></h2>
	<p>RxSwift Book / RayWenderlich</p>
	<p>BaseTrip</p>
	<p>RxSwift community</p>
	</br>

</br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br>
</div>
</section>
</body>
</html>
